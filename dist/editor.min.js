async function sign_in_with_email(email,password) {
	const res = await googleapis(
		'identitytoolkit.googleapis.com/v1/accounts:signInWithPassword',
		{ email, password, returnSecureToken: true }
	)
	if(res.error) {
        auth.modal.classList.remove('loading')
        auth.modal.classList.add('invalid')
        return false
    }
	set_auth(res.idToken,res.refreshToken)
}
async function sign_in_with_token(refresh_token) {
	if(!refresh_token) return false
	const res = await googleapis(
		'securetoken.googleapis.com/v1/token',
		{ refresh_token, grant_type: 'refresh_token' }
	)
	if(res.error) return false
	set_auth(res.id_token,res.refresh_token)
}
async function sign_out(){
    localStorage.setItem('refresh_token','')
    token = db = ''
    update_auth(false)
}
async function set_auth(idToken,refreshToken){
	token = '?auth='+idToken
	user = get_user(token)
	secrets = db(secrets)
	localStorage.setItem('refresh_token',refreshToken)
	update_auth(Boolean(user))
}
async function get_user(idToken){
	const res = await googleapis(
		'identitytoolkit.googleapis.com/v1/accounts:lookup',
		{ idToken }
	)
	return res.email
}
async function update_auth(signed_in){
	document.body.classList.toggle('signed-in',signed_in)
	auth.sign.value = `Sign ${signed_in ? 'out' : 'in'}`
	document.activeElement.blur()

	$('.remove',$editor).disabled
	= $('.publish',$editor).disabled
	= !signed_in
}
// The MIT License (MIT)

// Copyright (c) 2012 LDT Author, Colin Kuebler

// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


/* TextareaDecorator.js
 * written by Colin Kuebler 2012
 * Part of LDT, dual licensed under GPLv3 and MIT
 * Builds and maintains a styled output layer under a textarea input layer
 */

class Decorator {
	constructor(textarea, parser) {
		/* INIT */
		var api = this;

		// construct editor DOM
		var parent = document.createElement("div");
		var output = document.createElement("pre");
		parent.appendChild(output);
		var label = document.createElement("label");
		parent.appendChild(label);
		// replace the textarea with RTA DOM and reattach on label
		textarea.parentNode.replaceChild(parent, textarea);
		label.appendChild(textarea);
		// transfer the CSS styles to our editor
		parent.className = 'ldt ' + textarea.className;
		textarea.className = '';

		// coloring algorithm
		var color = function (input, output, parser) {
			var oldTokens = output.childNodes;
			var newTokens = parser.tokenize(input);
			var firstDiff, lastDiffNew, lastDiffOld;
			// find the first difference
			for (firstDiff = 0; firstDiff < newTokens.length && firstDiff < oldTokens.length; firstDiff++)
				if (newTokens[firstDiff] !== oldTokens[firstDiff].textContent)
					break;
			// trim the length of output nodes to the size of the input
			while (newTokens.length < oldTokens.length)
				output.removeChild(oldTokens[firstDiff]);
			// find the last difference
			for (lastDiffNew = newTokens.length - 1, lastDiffOld = oldTokens.length - 1; firstDiff < lastDiffOld; lastDiffNew--, lastDiffOld--)
				if (newTokens[lastDiffNew] !== oldTokens[lastDiffOld].textContent)
					break;
			// update modified spans
			for (; firstDiff <= lastDiffOld; firstDiff++) {
				oldTokens[firstDiff].className = parser.identify(newTokens[firstDiff]);
				oldTokens[firstDiff].textContent = oldTokens[firstDiff].innerText = newTokens[firstDiff];
			}
			// add in modified spans
			for (var insertionPt = oldTokens[firstDiff] || null; firstDiff <= lastDiffNew; firstDiff++) {
				var span = document.createElement("span");
				span.className = parser.identify(newTokens[firstDiff]);
				span.textContent = span.innerText = newTokens[firstDiff];
				output.insertBefore(span, insertionPt);
			}
		};

		api.input = textarea;
		api.output = output;
		api.update = function () {
			var input = textarea.value;
			if (input) {
				color(input, output, parser);
			} else {
				// clear the display
				output.innerHTML = '';
			}
		};

		// detect all changes to the textarea,
		// including keyboard input, cut/copy/paste, drag & drop, etc
		textarea.addEventListener("input", api.update, false);
		// initial highlighting
		api.update();

		return api;
	}
};

/* Parser.js
 * written by Colin Kuebler 2012
 * Part of LDT, dual licensed under GPLv3 and MIT
 * Generates a tokenizer from regular expressions for TextareaDecorator
 */

class Parser {
	constructor(rules, i) {
		/* INIT */
		var api = this;

		// variables used internally
		var i = i ? 'i' : '';
		var parseRE = null;
		var ruleSrc = [];
		var ruleMap = {};

		api.add = function (rules) {
			for (var rule in rules) {
				var s = rules[rule].source;
				ruleSrc.push(s);
				ruleMap[rule] = new RegExp('^(' + s + ')$', i);
			}
			parseRE = new RegExp(ruleSrc.join('|'), 'g' + i);
		};
		api.tokenize = function (input) {
			return input.match(parseRE);
		};
		api.identify = function (token) {
			for (var rule in ruleMap) {
				if (ruleMap[rule].test(token)) {
					return rule;
				}
			}
		};

		api.add(rules);

		return api;
	}
};

/* Keybinder.js
 * written by Colin Kuebler 2012
 * Part of LDT, dual licensed under GPLv3 and MIT
 * Simplifies the creation of keybindings on any element
 */

const Keybinder = {
	bind: function( element, keymap ){
		element.keymap = keymap;
		var keyNames = {
			8: "Backspace",
			9: "Tab",
			13: "Enter",
			16: "Shift",
			17: "Ctrl",
			18: "Alt",
			19: "Pause",
			20: "CapsLk",
			27: "Esc",
			33: "PgUp",
			34: "PgDn",
			35: "End",
			36: "Home",
			37: "Left",
			38: "Up",
			39: "Right",
			40: "Down",
			45: "Insert",
			46: "Delete",
			112: "F1",
			113: "F2",
			114: "F3",
			115: "F4",
			116: "F5",
			117: "F6",
			118: "F7",
			119: "F8",
			120: "F9",
			121: "F10",
			122: "F11",
			123: "F12",
			145: "ScrLk" };
		var keyEventNormalizer = function(e){
			// get the event object and start constructing a query
			var e = e || window.event;
			var query = "";
			// add in prefixes for each key modifier
			e.shiftKey && (query += "Shift-");
			e.ctrlKey && (query += "Ctrl-");
			e.altKey && (query += "Alt-");
			e.metaKey && (query += "Meta-");
			// determine the key code
			var key = e.which || e.keyCode || e.charCode;
			// if we have a name for it, use it
			if( keyNames[key] )
				query += keyNames[key];
			// otherwise turn it into a string
			else
				query += String.fromCharCode(key).toUpperCase();
			/* DEBUG */
			//console.log("keyEvent: "+query);
			// try to run the keybinding, cancel the event if it returns true
			if( element.keymap[query] && element.keymap[query]() ){
				e.preventDefault && e.preventDefault();
				e.stopPropagation && e.stopPropagation();
				return false;
			}
			return true;
		};
		// capture onkeydown and onkeypress events to capture repeating key events
		// maintain a boolean so we only fire once per character
		var fireOnKeyPress = true;
		element.onkeydown = function(e){
			fireOnKeyPress = false;
			return keyEventNormalizer(e);
		};
		element.onkeypress = function(e){
			if( fireOnKeyPress )
				return keyEventNormalizer(e);
			fireOnKeyPress = true;
			return true;
		};
	}
}

/* SelectHelper.js
 * written by Colin Kuebler 2012
 * Part of LDT, dual licensed under GPLv3 and MIT
 * Convenient utilities for cross browser textarea selection manipulation
 */

const SelectHelper = {
	add: function( element ){
		element.insertAtCursor = element.createTextRange ?
			// IE version
			function(x){
				document.selection.createRange().text = x;
			} :
			// standards version
			function(x){
				var s = element.selectionStart,
					e = element.selectionEnd,
					v = element.value;
				element.value = v.substring(0, s) + x + v.substring(e);
				s += x.length;
				element.setSelectionRange(s, s);
			};
	}
};

const $ = (query,parent=document) => parent.querySelector(query)
const $$ = (query,parent=document) => Array.from(parent.querySelectorAll(query))
let $editor, decorator
async function initEditor(){
    $editor = $('#editor')
    decorator = new Decorator(
        $('.markdown',$editor), 
        new Parser({
            bold: /([*_]{2}).*?\1/,
            italic: /([*_]).*?\1/,
            strike: /(~{2}).*?\1/,
            hr: /\s{0,3}([-+* ]{3,})$/,
            heading: /^#{1,6} *.+|(^|\n).+\n[-=]+$/,
            list: /^\s*((\d+\.)|[-+*])/,
            link: /(!?(\[.*?\]\((https?\:\/\/|mailto).*?\))|((https?\:\/\/|mailto)\S*))/,
            whitespace: /\s+/,
            other: /\S/,
        })
    ) 
    
    $('.markdown textarea',$editor).addEventListener('input',({target})=>{
        $('.body',$editor).innerHTML = md(target.value)
    })

    $('.render',$editor).addEventListener('click',({target})=>{
		const previewing = target.value == 'Preview'
		target.value = previewing ? 'Edit' : 'Preview'
		$editor.classList.toggle('render',previewing)
    })
}
async function editArticle(){
    const id = rot13(window.location.pathname.split('/').pop()) // Last portion of the path is the ciphered ID
    if(id.includes('-')) updateEditor(id)
}

async function updateEditor(id){
    const article = await db('articles/'+id)
    const markdown = await db('markdowns/'+id)
    const notif = await db('notifications/'+id)

	if (!article) return false

    document.title = article.title
    for(const property in article){
        const $element = $('.'+property,$editor)
        if(!$element) continue

        switch($element.type) {
            case 'checkbox':
            case 'radio':
                $element.checked = article[property]
                break
            default:
                $element.value = article[property]
                break
        }
    }
    $('.markdown textarea',$editor).value = $('.markdown pre').textContent = markdown
    decorator.update()

    $('.id',$editor).value = id

    if(article.notified) $('.notif',$editor).value = notif.notif

    for(const $textarea of $$('textarea',$editor))
        $textarea.dispatchEvent(new Event('input', {
            bubbles: true,
            cancelable: true,
        }))
}// The MIT License (MIT)

// Copyright (c) 2016 Sultan Tarimo

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/*!
 *             __
 *   __ _  ___/ /
 *  /  ' \/ _  / 
 * /_/_/_/\_,_/ 
 * 
 * md.js is a lightweight markdown parser
 * https://github.com/thysultan/md.js
 * 
 * @licence MIT
 */
(function (factory) {
	if (typeof exports === 'object' && typeof module !== 'undefined') {
		module.exports = factory();
	} else if (typeof define === 'function' && define.amd) {
		define(factory());
	} else {
		window.md = factory();
	}
}(function () {
	var unicodes = {
		'<': '&lt;',
		'>': '&gt;',
		'"': '&quot;',
		"'": '&#39;',
		'&': '&amp;',
		'[': '&#91;',
		']': '&#93;',
		'(': '&#40;',
		')': '&#41;',
	};

	var resc = /[<>&\(\)\[\]"']/g;

	function unicode (char) { return unicodes[char] || char; }

	var XSSFilterRegExp = /<(script)[^\0]*?>([^\0]+?)<\/(script)>/gmi;
	var XSSFilterTemplate = '&lt;$1&gt;$2&lt;/$3&gt;';

	var XSSFilterInlineJSRegExp = /(<.*? [^\0]*?=[^\0]*?)(javascript:.*?)(.*>)/gmi;
	var XSSFilterInlineJSTemplate = '$1#$2&#58;$3';

	var XSSFilterImageRegExp = /<img([^\0]*?onerror=)([^\0]*?)>/gmi;
	var XSSFilterImageTemplate = function (match, group1, group2) {
		return '<img' + group1 + group2.replace(resc, unicode) + '>';
	};

	var removeTabsRegExp = /^[\t ]+|[\t ]$/gm;

	var htmlFilterRegExp = /(<.*>[\t ]*\n^.*)/gm;
	var htmlFilterTemplate = function (match, group1) { 
		return group1.replace(/^\n|$\n/gm, '');
	};

	var cssFilterRegExp = /(<style>[^]*<\/style>)/gm;
	var cssFilterTemplate = htmlFilterTemplate;

	var eventsFilterRegExp = /(<[^]+?)(on.*?=.*?)(.*>)/gm;
	var eventsFilterTemplate = '$1$3';

	var blockQuotesRegExp = /^[ \t]*> (.*)/gm;
	var blockQuotesTemplate = '<blockquote>$1</blockquote>';

	var inlineCodeRegExp = /`([^`]+?)`/g;
	var inlineCodeTemplate = function (match, group1) {
		return '<code>'+group1.replace(resc, unicode)+'</code>'
	}

	var blockCodeRegExp = /```(.*)\n([^\0]+?)```(?!```)/gm;

	var imagesRegExp = /!\[(.*)\]\((.*)\)/g;
	var imagesTemplate = function (match, group1, group2) {
		var src = group2.replace(resc, unicode);
		var alt = group1.replace(resc, unicode);

		return '<img src="'+src+'" alt="'+alt+'">';
	};

	var headingsRegExp = /^(#+) +(.*)/gm;
	var headingsTemplate = function (match, hash, content) {
		var length = hash.length; return '<h'+length+'>'+content+'</h'+length+'>';
	};

	var headingsCommonh2RegExp = /^([^\n\t ])(.*)\n----+/gm;
	var headingsCommonh1RegExp = /^([^\n\t ])(.*)\n====+/gm;
	var headingsCommonh1Template = '<h1>$1$2</h1>';
	var headingsCommonh2Template = '<h2>$1$2</h2>';

	var paragraphsRegExp = /^([^-><#\d\+\_\*\t\n\[\! \{])([^]*?)(|  )(?:\n\n)/gm;
	var paragraphsTemplate = function (match, group1, group2, group3) {
		var leadingCharater = group1;
		var body = group2;
		
		var trailingSpace = group3 ? '\n<br>\n' : '\n';
		return '<p>'+leadingCharater+body+'</p>'+trailingSpace;
	};

	var horizontalRegExp = /^.*?(?:---|\*\*\*|- - -|\* \* \*)/gm;
	var horizontalTemplate = '<hr>';

	var strongRegExp = /(?:\*\*|\_\_)([^\*\n_]+?)(?:\*\*|\_\_)/g;
	var strongTemplate = '<strong>$1</strong>';

	var emphasisRegExp = /(?:\*|\_)([^\*\n_]+?)(?:\*|\_)/g;
	var emphasisTemplate = '<em>$1</em>';

	var strikeRegExp = /(?:~~)([^~]+?)(?:~~)/g;
	var strikeTemplate = '<del>$1</del>';

	var linksRegExp = /\[(.*?)\]\(([^\t\n ]*)(?:| "(.*)")\)+/gm;
	var linksTemplate = function (match, group1, group2, group3) {
		var link = group2.replace(resc, unicode);
		var text = group1.replace(resc, unicode);
		var title = group3 ? ' title="'+group3.replace(resc, unicode)+'"' : '';

		return '<a href="'+link+'"'+title+'>'+text+'</a>';
	};

	var listUlRegExp1 = /^[\t ]*?(?:-|\+|\*) (.*)/gm;
	var listUlRegExp2 = /(\<\/ul\>\n(.*)\<ul\>*)+/g;
	var listUlTemplate = '<ul><li>$1</li></ul>';

	var listOlRegExp1 = /^[\t ]*?(?:\d(?:\)|\.)) (.*)/gm;
	var listOlRegExp2 = /(\<\/ol\>\n(.*)\<ol\>*)+/g;
	var listOlTemplate = '<ol><li>$1</li></ol>';

	var lineBreaksRegExp = /^\n\n+/gm;
	var lineBreaksTemplate = '<br>';

	var checkBoxesRegExp = /\[( |x)\]/g;
	var checkBoxesTemplate = function (match, group1) {
		return '<input type="checkbox" disabled' + (group1.toLowerCase() === 'x' ? ' checked' : '') + '>'
	};


	/**
	 * markdown parser
	 * 
	 * @param  {string} markdown
	 * @return {string}
	 */
	function md (markdown) {
		if (!markdown) {
			return '';
		}

		var code = [];
		var index = 0;
		var length = markdown.length;

		// to allow matching trailing paragraphs
		if (markdown[length-1] !== '\n' && markdown[length-2] !== '\n') {
			markdown += '\n\n';
		}

		// format, removes tabs, leading and trailing spaces
		markdown = (
			markdown
				// collect code blocks and replace with placeholder
				// we do this to avoid code blocks matching the paragraph regexp
				.replace(blockCodeRegExp, function (match, lang, block) {
					var placeholder = '{code-block-'+index+'}';
					var regex = new RegExp('{code-block-'+index+'}', 'g');

					code[index++] = {lang: lang, block: block.replace(resc, unicode), regex: regex};

					return placeholder;
				})
				// XSS script tags
				.replace(XSSFilterRegExp, XSSFilterTemplate)
				// XSS image onerror
				.replace(XSSFilterImageRegExp, XSSFilterImageTemplate)
				// filter events
				.replace(eventsFilterRegExp, eventsFilterTemplate)
				// tabs
				.replace(removeTabsRegExp, '')
				// blockquotes
				.replace(blockQuotesRegExp, blockQuotesTemplate)
				// images
				.replace(imagesRegExp, imagesTemplate)
				// headings
				.replace(headingsRegExp, headingsTemplate)
				// headings h1 (commonmark)
				.replace(headingsCommonh1RegExp, headingsCommonh1Template)
				// headings h2 (commonmark)
				.replace(headingsCommonh2RegExp, headingsCommonh2Template)
				// horizontal rule 
				.replace(horizontalRegExp, horizontalTemplate)
				// checkboxes
				.replace(checkBoxesRegExp, checkBoxesTemplate)
				// filter html
				.replace(htmlFilterRegExp, htmlFilterTemplate)
				// filter css
				.replace(cssFilterRegExp, cssFilterTemplate)
				// paragraphs
				.replace(paragraphsRegExp, paragraphsTemplate)
				// inline code
				.replace(inlineCodeRegExp, inlineCodeTemplate)
				// links
				.replace(linksRegExp, linksTemplate)
				// unorderd lists
				.replace(listUlRegExp1, listUlTemplate).replace(listUlRegExp2, '')
				// ordered lists
				.replace(listOlRegExp1, listOlTemplate).replace(listOlRegExp2, '')
				// strong
				.replace(strongRegExp, strongTemplate)
				// emphasis
				.replace(emphasisRegExp, emphasisTemplate)
				// strike through
				.replace(strikeRegExp, strikeTemplate)
				// line breaks
				.replace(lineBreaksRegExp, lineBreaksTemplate)
				// filter inline js
				.replace(XSSFilterInlineJSRegExp, XSSFilterInlineJSTemplate)
		);

		// replace code block placeholders
		for (var i = 0; i < index; i++) {
			var item = code[i];
			var lang = item.lang;
			var block = item.block;

			markdown = markdown.replace(item.regex, function (match) {
				return '<pre><code class="language-'+lang+'">'+block+'</code></pre>';
			});
		}

		return markdown.trim();
	}

	return md;
}));const $templatePreview = $('#template-preview')

function makePreview(id,snippet){
	const $preview = $templatePreview.content.cloneNode(true).querySelector('article')

	$preview.id = 'preview-'+id

	const $title = $('.title',$preview)
	$title.addEventListener('click',event=>{
		document.title = snippet.title
		history.pushState({}, '', rot13(id))
		editArticle()
		event.preventDefault()		
	})
	$title.href = rot13(id)

	const $featured = $('.featured',$preview)
	$featured.addEventListener('change',()=>{
		const featured = {featured:$featured.checked}
		db('snippets/'+id,featured)
		db('articles/'+id,featured)
		postWebhook(id,($featured.checked ? 'â­ ' : 'ðŸ’” ') + snippet.title,'')
	})

	updatePreview($preview,snippet)

	return $preview
}

function updatePreview($preview,snippet){
	$('.title',$preview).innerHTML = snippet.title
	$('.featured',$preview).checked = snippet.featured
}const db_path = path => 'https://ahs-app.firebaseio.com/'+path+'.json'+token
async function post(path,request){
	const response = await fetch('https://'+path,
		{
			body: JSON.stringify(request),
			headers: { 'Content-Type': 'application/json' },
			method: 'POST',
		}	
	) 
	return await response.json()
}
async function db(path,request){
	const response = await fetch(
		db_path(path),
		request ? {
			body: JSON.stringify(request),
			headers: { 'Content-Type': 'application/json' },
			method: 'PATCH',
		} : {}
	)
	return await response.json()
}
async function googleapis(path,request){
	return await post(path+'?key='+KEY,request)
}
const get_timestamp = async () => Math.floor(Date.now()/1000)
const rot13 = string => string.replace(/\w/g,c=>'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'['ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.indexOf(c)])
/////////////
/* WEBHOOK */
/////////////

async function postWebhook(id,title,description){
	const payload = {
		username: 'ACES edit log',
		avatar_url: 'https://internal.ahs.app/icon.png',
		content: '',
		embeds: [{
			color: 0x995eff,
			author: {
				name: 'hello',
			},
			url: 'https://editor.ahs.app/'+id,
			title,
			description,
		}],
	}
	const response = await post(await db('secrets/webhook'),payload)
	console.log(response)
}
const KEY = 'AIzaSyDEUekXeyIKJUreRaX78lsEYBt8JGHYmHE'
let user = ''
let token = ''
let secrets

sign_in_with_token(localStorage.getItem('refresh_token'))

const auth = {
	sign: $`.sign`,
	modal: $`.sign-in`,

	email: $`.email`,
	password: $`.password`,
}
auth.modal
 .addEventListener('submit',event=>{
	event.preventDefault()
	sign_in_with_email(
		auth.email.value,
		auth.password.value,
	)
	auth.modal.reset()
	auth.modal.classList.add('loading')
})
auth.modal
 .addEventListener('input',event=>{
	 auth.modal.classList.remove('invalid')
 })
auth.sign
 .addEventListener('click', event=>{
	event.preventDefault()
	if(user){
		sign_out()
	} else{
		auth.email.focus()
	}
 })
auth.modal
 .querySelector('.cancel')
 .addEventListener('click', ()=>{
	document.activeElement.blur()
})
"use strict"

const DEBUG = false

//////////
/* INIT */
//////////

const $browser = $`#browser`

async function init(){
	initEditor()
	editArticle()

	const layout = await db('layout')
	const snippets = await db('snippets')

	$browser.append(
		...layout.map(
			location => makeGroup(location.title,location.categories.map(
					category => makeGroup(category.title,category.articleIDs.map(
							id => makePreview(id,snippets[id])
	))))))
	
	for(const $textarea of $$`textarea`){
		$textarea.setAttribute('rows',1)
		$textarea.addEventListener('input',()=>{
			$textarea.style.height = 'auto'
			$textarea.style.height = $textarea.scrollHeight+'px'
		})
	}
}
function makeGroup(title,children){
	const $group = document.createElement`details`
	const $heading = document.createElement`summary`
	const $rest = document.createElement`section`
	$heading.innerHTML = title
	$rest.append(...children)
	$group.append($heading,$rest)
	$group.setAttribute('open','')
	return $group
}

init()
